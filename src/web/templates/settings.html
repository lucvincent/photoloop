<!-- Copyright (c) 2025-2026 Luc Vincent. All Rights Reserved. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhotoLoop Dashboard</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1a1a2e">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PhotoLoop">
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32.png') }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ url_for('static', filename='favicon-16.png') }}">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='apple-touch-icon.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo-title">
                <img src="{{ url_for('static', filename='logo.svg') }}" alt="PhotoLoop">
                <h1>PhotoLoop<span class="title-dashboard"> Dashboard</span></h1>
            </div>
            <div id="status-indicator" class="status">Loading...</div>
        </header>

        <nav class="tabs">
            <button class="tab active" data-tab="control">Control</button>
            <button class="tab" data-tab="albums">Albums</button>
            <button class="tab" data-tab="display">Display</button>
            <button class="tab" data-tab="schedule">Screensaver</button>
            <button class="tab" data-tab="clock">Clock</button>
            <button class="tab" data-tab="cache">Cache</button>
        </nav>

        <!-- Control Tab -->
        <section id="control" class="tab-content active">
            <h2>Photo Control</h2>
            <div class="control-buttons" id="photo-control-buttons" style="margin-bottom: 8px;">
                <button id="btn-prev" class="btn btn-primary photo-control-btn"><span class="btn-icon">‚èÆ</span><span class="btn-text">Previous</span></button>
                <button id="btn-pause" class="btn btn-primary photo-control-btn"><span class="btn-icon">‚è∏</span><span class="btn-text">Pause</span></button>
                <button id="btn-next" class="btn btn-primary photo-control-btn"><span class="btn-icon">‚è≠</span><span class="btn-text">Next</span></button>
            </div>
            <p class="help-text" id="photo-control-status">
                Use these controls to navigate photos or pause the slideshow on a specific photo.
            </p>

            <h2>Display Mode</h2>
            <div class="mode-buttons">
                <button id="btn-slideshow" class="btn btn-mode" data-mode="slideshow" title="Show photos">
                    <span class="mode-icon">‚ñ∂</span>
                    <span class="mode-text">Slideshow</span>
                </button>
                <button id="btn-clock" class="btn btn-mode" data-mode="clock" title="Show clock">
                    <span class="mode-icon">üïê</span>
                    <span class="mode-text">Clock</span>
                </button>
                <button id="btn-black" class="btn btn-mode" data-mode="black" title="Turn off display">
                    <span class="mode-icon">‚¨õ</span>
                    <span class="mode-text">Black Screen</span>
                </button>
                <button id="btn-resume" class="btn btn-mode btn-resume" title="Return to scheduled mode" style="display: none;">
                    <span class="mode-icon">‚Ü©</span>
                    <span class="mode-text">Resume Schedule</span>
                </button>
            </div>
            <div id="no-content-msg" class="help-text" style="display: none; color: var(--warning); margin-top: 8px;">
                Enable albums and sync to download photos.
            </div>

            <div class="status-box" style="margin-top: 20px;">
                <h3 style="margin-top: 0;">
                    Status: <span id="state" class="status-badge">-</span>
                    <span id="mode-reason" class="mode-reason"></span>
                </h3>
                <div id="current-status">
                    <p><strong>Next Change:</strong> <span id="next-transition">-</span></p>
                    <p><strong>Photos Cached:</strong> <span id="photo-count">-</span></p>
                    <p><strong>Cache Size:</strong> <span id="cache-size">-</span> MB</p>
                </div>
            </div>

            <h2>Album Sync</h2>
            <p class="help-text" style="margin-bottom: 12px;">
                Only enabled sources (marked "Show" in the Albums tab) will be synced.
            </p>

            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div class="form-group" style="flex: 1; min-width: 180px;">
                    <label for="sync-interval">Automatic Sync Interval</label>
                    <select id="sync-interval">
                        <option value="0">Never (manual only)</option>
                        <option value="60">Hourly</option>
                        <option value="360">Every 6 hours</option>
                        <option value="720">Every 12 hours</option>
                        <option value="1440" selected>Daily (24 hours)</option>
                        <option value="2880">Every 2 days</option>
                        <option value="10080">Weekly</option>
                    </select>
                </div>

                <div class="form-group" style="flex: 1; min-width: 140px;">
                    <label for="sync-time">Automatic Sync Time</label>
                    <input type="time" id="sync-time" value="03:00">
                </div>
            </div>

            <div class="form-group">
                <label class="checkbox-inline">
                    <input type="checkbox" id="sync-on-start">
                    Sync on service start
                </label>
            </div>

            <div class="form-group">
                <label for="sync-max-dimension">Max Pixel Dimension of Downloaded Photos</label>
                <input type="number" id="sync-max-dimension" min="0" max="8000" step="100" value="0" style="width: 120px;">
                <p class="help-text" style="margin-top: 4px;">0 = full resolution. Set a value (e.g., 1920) to download smaller versions and save space. Does not apply to local photo albums.</p>
            </div>

            <button id="btn-save-sync" class="btn btn-primary" style="margin-bottom: 20px;">Save Sync Settings</button>

            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <button id="btn-sync" class="btn btn-primary">Sync Now</button>
                    <button id="btn-full-sync" class="btn btn-primary">Full Sync Now</button>
                    <button id="btn-stop-sync" class="btn btn-danger" disabled>Stop Sync</button>
                </div>
                <p class="help-text" style="margin-top: 8px;">
                    Full Sync also re-fetches photo metadata for remote albums (slower). Otherwise, only new photos get metadata.
                </p>
            </div>

            <div id="sync-progress" class="sync-progress-box" style="display: none;">
                <div id="sync-stage-header" style="font-weight: 600; margin-bottom: 8px;">Stage 1 of 3: Scanning albums</div>
                <div id="sync-album-info" style="color: var(--text-secondary); margin-bottom: 8px;"></div>
                <div class="progress-bar-container">
                    <div id="sync-progress-bar"></div>
                </div>
                <div id="sync-progress-text" style="margin-top: 4px;"></div>
                <div id="sync-stop-message" style="margin-top: 8px; color: var(--text-secondary); display: none;"></div>
            </div>
        </section>

        <!-- Albums Tab -->
        <section id="albums" class="tab-content">
            <h2>Photo Sources</h2>

            <div class="source-type-tabs" style="display: flex; gap: 0; margin-bottom: 15px;">
                <button class="source-tab active" data-source="google" style="flex: 1; padding: 10px; border: 1px solid var(--border); border-radius: 8px 0 0 8px; background: var(--sage-primary); color: white; cursor: pointer;">Google Photos</button>
                <button class="source-tab" data-source="local" style="flex: 1; padding: 10px; border: 1px solid var(--border); border-left: none; border-radius: 0 8px 8px 0; background: var(--card-bg); color: var(--text-secondary); cursor: pointer;">Local Directory</button>
            </div>

            <!-- Google Photos Input -->
            <div id="google-input" class="source-input">
                <div class="form-group">
                    <label for="new-album-url">Album URL</label>
                    <input type="url" id="new-album-url" placeholder="https://photos.app.goo.gl/...">
                </div>
                <div class="form-group">
                    <label for="new-album-name">Album Name (optional)</label>
                    <input type="text" id="new-album-name" placeholder="My Album">
                </div>
                <button id="btn-add-album" class="btn btn-primary">Add Google Album</button>
            </div>

            <!-- Local Directory Input -->
            <div id="local-input" class="source-input" style="display: none;">
                <div class="form-group">
                    <label for="new-local-path">Directory Path</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="new-local-path" placeholder="/home/pi/photos" style="flex: 1;">
                        <button id="btn-browse-dir" class="btn btn-small" type="button" style="align-self: center;">Browse...</button>
                    </div>
                    <p class="help-text" style="margin-top: 4px; font-size: 12px;">Enter the full path or use Browse to select a directory.</p>
                </div>
                <div class="form-group">
                    <label for="new-local-name">Display Name (optional)</label>
                    <input type="text" id="new-local-name" placeholder="My Local Photos">
                </div>
                <button id="btn-add-local" class="btn btn-primary">Add Local Directory</button>
            </div>

            <h3>Configured Sources</h3>
            <p class="hint">Changes in source selection take effect immediately.</p>
            <ul id="album-list" class="album-list">
                <!-- Albums will be loaded here -->
            </ul>

            <!-- Directory Browser Modal -->
            <div id="dir-browser-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Select Directory</h3>
                    <div id="browser-path" class="browser-path">/home</div>
                    <button id="btn-browser-up" class="btn btn-small" type="button">‚Üë Parent Directory</button>
                    <ul id="browser-list" class="browser-list">
                        <!-- Directories will be loaded here -->
                    </ul>
                    <p class="help-text" style="margin-top: 8px; font-size: 11px;">
                        Photo counts shown are for that directory only. Subdirectories will be included when syncing.
                    </p>
                    <div class="modal-buttons">
                        <button id="btn-browser-select" class="btn btn-primary" type="button">Select This Directory</button>
                        <button id="btn-browser-cancel" class="btn" type="button">Cancel</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Display Tab -->
        <section id="display" class="tab-content">
            <h2>Display Settings</h2>
            <p class="hint">Changes take effect immediately after saving.</p>

            <div class="form-group">
                <label for="photo-duration">Photo Duration (seconds)</label>
                <input type="number" id="photo-duration" min="5" max="300"
                       value="{{ config.display.photo_duration_seconds }}">
            </div>

            <div class="form-group">
                <label for="transition-type">Transition Type</label>
                <select id="transition-type">
                    <option value="fade" {% if config.display.transition_type == 'fade' %}selected{% endif %}>Fade</option>
                    <option value="slide_left" {% if config.display.transition_type == 'slide_left' %}selected{% endif %}>Slide Left</option>
                    <option value="slide_right" {% if config.display.transition_type == 'slide_right' %}selected{% endif %}>Slide Right</option>
                    <option value="slide_up" {% if config.display.transition_type == 'slide_up' %}selected{% endif %}>Slide Up</option>
                    <option value="slide_down" {% if config.display.transition_type == 'slide_down' %}selected{% endif %}>Slide Down</option>
                    <option value="random" {% if config.display.transition_type == 'random' %}selected{% endif %}>Random</option>
                </select>
            </div>

            <div class="form-group">
                <label for="display-order">Photo Order</label>
                <select id="display-order">
                    <option value="random" {% if config.display.order == 'random' %}selected{% endif %}>Random</option>
                    <option value="recency_weighted" {% if config.display.order == 'recency_weighted' %}selected{% endif %}>Random with Recency Bias</option>
                    <option value="alphabetical" {% if config.display.order == 'alphabetical' %}selected{% endif %}>Alphabetical (by filename)</option>
                    <option value="chronological" {% if config.display.order == 'chronological' %}selected{% endif %}>Chronological (by date)</option>
                </select>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="overlay-enabled"
                           {% if config.overlay.enabled %}checked{% endif %}>
                    Show Date/Caption Overlay
                </label>
            </div>

            <div class="form-group" id="overlay-font-size-group" style="display: flex; align-items: center; gap: 12px;">
                <label for="overlay-font-size" style="margin: 0;">Overlay Text Size (pixels)</label>
                <input type="number" id="overlay-font-size" min="12" max="200"
                       value="{{ config.overlay.font_size }}" style="width: 100px;">
            </div>

            <button id="btn-save-display" class="btn btn-primary" style="margin-top: 20px;">Save Display Settings</button>
        </section>

        <!-- Schedule Tab (Screen Saver) -->
        <section id="schedule" class="tab-content">
            <h2>Screen Saver Settings</h2>

            <h3>Default Mode</h3>
            <div class="form-group">
                <label for="default-screensaver-mode">When slideshow is stopped or has no photos:</label>
                <select id="default-screensaver-mode">
                    <option value="black">Black Screen (Display Off)</option>
                    <option value="clock">Clock</option>
                </select>
                <p class="help-text" style="margin-top: 4px;">Configure clock appearance in the Clock tab.</p>
            </div>

            <h3 style="margin-top: 25px;">Schedule</h3>
            <div class="form-group">
                <label class="checkbox-inline">
                    <input type="checkbox" id="schedule-enabled-control">
                    Enable Schedule
                </label>
                <p class="help-text" style="margin-top: 4px;">Automatically switch between slideshow, clock, and off at scheduled times. When disabled, use Start/Stop buttons manually.</p>
            </div>

            <div id="schedule-details">
                <h4 style="margin-bottom: 10px;">Weekday Schedule (Mon-Fri)</h4>
                <div id="weekday-events" class="event-list">
                    <!-- Events loaded dynamically -->
                </div>
                <button type="button" class="btn btn-small btn-add-event" onclick="addEvent('weekday-events')">+ Add Time Period</button>

                <h4 style="margin-top: 20px; margin-bottom: 10px;">Weekend Schedule (Sat-Sun)</h4>
                <div id="weekend-events" class="event-list">
                    <!-- Events loaded dynamically -->
                </div>
                <button type="button" class="btn btn-small btn-add-event" onclick="addEvent('weekend-events')">+ Add Time Period</button>

                <h4 style="margin-top: 20px; margin-bottom: 10px;">Holiday Schedule</h4>
                <div class="form-group">
                    <label class="checkbox-inline">
                        <input type="checkbox" id="holidays-use-weekend">
                        Use weekend schedule on holidays
                    </label>
                    <p class="help-text" style="margin-top: 4px;">When enabled, public holidays follow the weekend schedule instead of weekday.</p>
                </div>
                <div id="holiday-countries" style="margin-left: 20px; display: none;">
                    <label style="margin-bottom: 8px; display: block;">Select holiday calendars:</label>
                    <div class="holiday-checkboxes" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px;">
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="US"> United States</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="GB"> United Kingdom</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="CA"> Canada</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="AU"> Australia</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="DE"> Germany</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="FR"> France</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="ES"> Spain</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="IT"> Italy</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="NL"> Netherlands</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="BE"> Belgium</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="CH"> Switzerland</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="AT"> Austria</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="IL"> Israel</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="JP"> Japan</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="MX"> Mexico</label>
                        <label class="checkbox-inline"><input type="checkbox" class="holiday-country" value="BR"> Brazil</label>
                    </div>
                </div>
            </div>

            <button id="btn-save-schedule" class="btn btn-primary" style="margin-top: 20px;">Save</button>
        </section>

        <!-- Clock Tab -->
        <section id="clock" class="tab-content">
            <h2>Clock Display</h2>
            <p class="hint">Settings for the clock shown during off-hours (when "Clock" is selected in Schedule).</p>

            <h3>Clock Appearance</h3>
            <div class="form-group">
                <label for="clock-style">Clock Style</label>
                <select id="clock-style">
                    <option value="digital_24h" {% if config.clock.style == 'digital_24h' %}selected{% endif %}>Digital 24-Hour</option>
                    <option value="digital_12h" {% if config.clock.style == 'digital_12h' %}selected{% endif %}>Digital 12-Hour</option>
                    <option value="digital_seconds" {% if config.clock.style == 'digital_seconds' %}selected{% endif %}>Digital with Seconds</option>
                    <option value="digital_large" {% if config.clock.style == 'digital_large' %}selected{% endif %}>Digital Large</option>
                    <option value="analog_classic" {% if config.clock.style == 'analog_classic' %}selected{% endif %}>Analog Classic</option>
                    <option value="analog_modern" {% if config.clock.style == 'analog_modern' %}selected{% endif %}>Analog Modern</option>
                    <option value="minimal_time" {% if config.clock.style == 'minimal_time' %}selected{% endif %}>Minimal Time</option>
                    <option value="minimal_date" {% if config.clock.style == 'minimal_date' %}selected{% endif %}>Minimal Date</option>
                </select>
            </div>

            <div class="form-group">
                <label for="clock-size">Clock Size</label>
                <select id="clock-size">
                    <option value="small" {% if config.clock.size == 'small' %}selected{% endif %}>Small</option>
                    <option value="medium" {% if config.clock.size == 'medium' %}selected{% endif %}>Medium</option>
                    <option value="large" {% if config.clock.size == 'large' %}selected{% endif %}>Large</option>
                </select>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="clock-show-date"
                           {% if config.clock.show_date %}checked{% endif %}>
                    Show Date
                </label>
            </div>

            <h3 style="margin-top: 25px;">Weather (Optional)</h3>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="weather-enabled"
                           {% if config.weather.enabled %}checked{% endif %}>
                    Show Weather
                </label>
            </div>

            <div id="weather-settings" style="margin-left: 20px; {% if not config.weather.enabled %}display: none;{% endif %}">
                <div class="form-group">
                    <label for="weather-city">City Name (for display)</label>
                    <input type="text" id="weather-city" placeholder="e.g., San Francisco"
                           value="{{ config.weather.city_name }}">
                </div>
                <div class="time-range">
                    <div class="form-group">
                        <label for="weather-lat">Latitude</label>
                        <input type="number" id="weather-lat" step="0.0001" placeholder="37.7749"
                               value="{{ config.weather.latitude if config.weather.latitude else '' }}">
                    </div>
                    <div class="form-group">
                        <label for="weather-lon">Longitude</label>
                        <input type="number" id="weather-lon" step="0.0001" placeholder="-122.4194"
                               value="{{ config.weather.longitude if config.weather.longitude else '' }}">
                    </div>
                </div>
                <p class="help-text" style="margin-top: 4px;">Find coordinates at <a href="https://www.latlong.net/" target="_blank" style="color: var(--sage-primary);">latlong.net</a></p>
                <div class="form-group">
                    <label for="weather-units">Temperature Units</label>
                    <select id="weather-units">
                        <option value="fahrenheit" {% if config.weather.units == 'fahrenheit' %}selected{% endif %}>Fahrenheit</option>
                        <option value="celsius" {% if config.weather.units == 'celsius' %}selected{% endif %}>Celsius</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="weather-font-size">Text Size</label>
                    <input type="number" id="weather-font-size" min="0" max="400" step="10"
                           value="{{ config.weather.font_size }}" placeholder="0 = auto">
                    <p class="help-text" style="margin-top: 4px;">0 = auto-scale. Actual height is ~68% of this value. Try 200-300 for viewing from across the room.</p>
                </div>
            </div>

            <h3 style="margin-top: 25px;">News Headlines (Optional)</h3>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="news-enabled"
                           {% if config.news.enabled %}checked{% endif %}>
                    Show News Headlines
                </label>
            </div>

            <div id="news-settings" style="margin-left: 20px; {% if not config.news.enabled %}display: none;{% endif %}">
                <div class="form-group">
                    <label for="news-feeds">RSS Feed URLs (one per line, # to disable)</label>
                    <textarea id="news-feeds" rows="12"
                              placeholder="# Remove # to enable a feed&#10;https://feeds.bbci.co.uk/news/rss.xml&#10;# https://feeds.npr.org/1001/rss.xml&#10;# https://rss.nytimes.com/services/xml/rss/nyt/HomePage.xml">{{ config.news.feed_urls | join('\n') }}</textarea>
                    <p class="help-text" style="margin-top: 4px;">Lines starting with # are disabled. Remove # to enable a feed.</p>
                </div>
                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                    <div class="form-group" style="flex: 1; min-width: 150px;">
                        <label for="news-refresh">Refresh Interval</label>
                        <select id="news-refresh">
                            <option value="1" {% if config.news.refresh_interval_minutes == 1 %}selected{% endif %}>1 minute</option>
                            <option value="2" {% if config.news.refresh_interval_minutes == 2 %}selected{% endif %}>2 minutes</option>
                            <option value="5" {% if config.news.refresh_interval_minutes == 5 %}selected{% endif %}>5 minutes</option>
                            <option value="10" {% if config.news.refresh_interval_minutes == 10 %}selected{% endif %}>10 minutes</option>
                            <option value="15" {% if config.news.refresh_interval_minutes == 15 %}selected{% endif %}>15 minutes</option>
                            <option value="30" {% if config.news.refresh_interval_minutes == 30 %}selected{% endif %}>30 minutes</option>
                        </select>
                    </div>
                    <div class="form-group" style="flex: 1; min-width: 150px;">
                        <label for="news-max-headlines">Max Headlines</label>
                        <select id="news-max-headlines">
                            <option value="5" {% if config.news.max_headlines == 5 %}selected{% endif %}>5</option>
                            <option value="10" {% if config.news.max_headlines == 10 %}selected{% endif %}>10</option>
                            <option value="15" {% if config.news.max_headlines == 15 %}selected{% endif %}>15</option>
                            <option value="20" {% if config.news.max_headlines == 20 %}selected{% endif %}>20</option>
                            <option value="30" {% if config.news.max_headlines == 30 %}selected{% endif %}>30</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="news-scroll-speed">Scroll Speed: <span id="scroll-speed-value">{{ config.news.scroll_speed }}</span> px/s</label>
                    <input type="range" id="news-scroll-speed" min="60" max="300" step="10"
                           value="{{ config.news.scroll_speed }}"
                           oninput="document.getElementById('scroll-speed-value').textContent = this.value">
                    <p class="help-text" style="margin-top: 4px;">Faster = quicker scrolling (150-200 recommended)</p>
                </div>
                <div class="form-group">
                    <label for="news-font-size">Text Size</label>
                    <input type="number" id="news-font-size" min="0" max="250" step="10"
                           value="{{ config.news.font_size }}" placeholder="0 = auto">
                    <p class="help-text" style="margin-top: 4px;">0 = auto-scale. Actual height is ~68% of value. Long headlines auto-truncate at large sizes.</p>
                </div>
            </div>

            <button id="btn-save-clock" class="btn btn-primary" style="margin-top: 20px;">Save Clock Settings</button>
        </section>

        <!-- Cache Tab -->
        <section id="cache" class="tab-content">
            <h2>Cache Management</h2>

            <div class="status-box" style="margin-top: 15px;">
                <p><strong>Cache Directory:</strong> {{ config.cache.directory }}</p>
                <p><strong>Max Size:</strong> {{ config.cache.max_size_mb }} MB</p>
                <p><strong>Current Size:</strong> <span id="cache-size-detail">-</span></p>
                <p><strong>Photos:</strong> <span id="photo-count-detail">-</span></p>
                <p><strong>Videos:</strong> <span id="video-count-detail">-</span></p>
            </div>

            <h3>Cached Photos <span id="photo-grid-count" style="font-weight: normal; font-size: 14px; color: #81d4fa;"></span></h3>
            <p style="margin: 5px 0 10px 0; font-size: 13px; color: #888;">Newest additions first. Note: Photos deleted from local directories will show as empty frames until the next sync.</p>
            <div id="photo-grid" class="photo-grid" style="max-height: 500px; overflow-y: auto; border: 1px solid #333; border-radius: 8px; padding: 10px; background: #16213e;">
                <!-- Thumbnails will be loaded here -->
            </div>

            <button id="btn-clear-cache" class="btn btn-danger" style="margin-top: 15px;">Clear Cache</button>
        </section>

        <footer class="copyright">
            Copyright ¬© Luc Vincent, 2025 ‚Äî All Rights Reserved
        </footer>
    </div>

    <script>
        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .then((registration) => {
                    console.log('ServiceWorker registered:', registration.scope);
                })
                .catch((error) => {
                    console.log('ServiceWorker registration failed:', error);
                });
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });

        // API helpers
        async function apiCall(endpoint, method = 'GET', data = null) {
            const options = { method };
            if (data) {
                options.headers = { 'Content-Type': 'application/json' };
                options.body = JSON.stringify(data);
            }
            const response = await fetch(endpoint, options);
            return response.json();
        }

        // Format ISO datetime for display (e.g., "Dec 30, 3:15 PM")
        function formatSyncTime(isoString) {
            const date = new Date(isoString);
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        // Load status
        async function loadStatus() {
            try {
                const status = await apiCall('/api/status');

                if (status.schedule) {
                    const stateEl = document.getElementById('state');
                    const modeReasonEl = document.getElementById('mode-reason');
                    const displayMode = status.schedule.display_mode;
                    const modeReason = status.schedule.mode_reason;
                    const isPaused = status.photo_control && status.photo_control.paused;
                    const hasContent = status.has_content !== false;
                    const hasOverride = status.schedule.has_override;

                    // Determine status badge text and class based on display_mode
                    let displayText, badgeClass;

                    if (displayMode === 'slideshow') {
                        if (!hasContent) {
                            displayText = 'No Albums or Photos';
                            badgeClass = 'status-badge stopped';
                        } else if (isPaused) {
                            displayText = 'Slideshow Paused';
                            badgeClass = 'status-badge paused';
                        } else {
                            displayText = 'Slideshow Running';
                            badgeClass = 'status-badge running';
                        }
                    } else if (displayMode === 'clock') {
                        displayText = 'Clock';
                        badgeClass = 'status-badge clock';
                    } else if (displayMode === 'black') {
                        displayText = 'Display Off';
                        badgeClass = 'status-badge off';
                    } else {
                        displayText = displayMode || '-';
                        badgeClass = 'status-badge';
                    }

                    stateEl.textContent = displayText;
                    stateEl.className = badgeClass;

                    // Show mode reason (scheduled, manual, disabled)
                    let reasonText = '';
                    if (modeReason === 'manual') {
                        reasonText = '(Manual)';
                    } else if (modeReason === 'scheduled') {
                        reasonText = '(Scheduled)';
                    } else if (modeReason === 'disabled') {
                        reasonText = '(Schedule Disabled)';
                    }
                    modeReasonEl.textContent = reasonText;

                    // Update mode buttons - highlight active mode
                    document.querySelectorAll('.btn-mode[data-mode]').forEach(btn => {
                        const btnMode = btn.dataset.mode;
                        if (btnMode === displayMode) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });

                    // Show Resume button only when there's an active override
                    const resumeBtn = document.getElementById('btn-resume');
                    resumeBtn.style.display = hasOverride ? '' : 'none';

                    // Disable slideshow button if no content
                    const slideshowBtn = document.getElementById('btn-slideshow');
                    const noContentMsg = document.getElementById('no-content-msg');
                    if (!hasContent) {
                        slideshowBtn.disabled = true;
                        slideshowBtn.classList.add('disabled');
                        noContentMsg.style.display = '';
                    } else {
                        slideshowBtn.disabled = false;
                        slideshowBtn.classList.remove('disabled');
                        noContentMsg.style.display = 'none';
                    }

                    // Update next transition
                    if (status.schedule.next_transition && status.schedule.next_transition.time) {
                        const nextTime = new Date(status.schedule.next_transition.time);
                        const timeStr = nextTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        document.getElementById('next-transition').textContent =
                            `${status.schedule.next_transition.description} at ${timeStr}`;
                    } else if (hasOverride) {
                        document.getElementById('next-transition').textContent = 'None (manual control active)';
                    } else if (!status.schedule_enabled) {
                        document.getElementById('next-transition').textContent = 'None (schedule disabled)';
                    } else {
                        document.getElementById('next-transition').textContent = '-';
                    }
                }

                if (status.cache) {
                    document.getElementById('photo-count').textContent = status.cache.counts.photos;
                    document.getElementById('cache-size').textContent = status.cache.size_mb;
                    document.getElementById('photo-count-detail').textContent = status.cache.counts.photos;
                    document.getElementById('video-count-detail').textContent = status.cache.counts.videos;
                    // Show breakdown: "XX MB (downloaded: XX MB, pre-rendered: XX MB)"
                    const breakdown = status.cache.size_breakdown;
                    if (breakdown) {
                        document.getElementById('cache-size-detail').textContent =
                            `${breakdown.total} MB (downloaded: ${breakdown.downloaded} MB, pre-rendered: ${breakdown.rendered} MB)`;
                    } else {
                        document.getElementById('cache-size-detail').textContent = status.cache.size_mb + ' MB';
                    }
                }

                // Sync schedule enabled checkbox
                if (status.schedule_enabled !== undefined) {
                    document.getElementById('schedule-enabled-control').checked = status.schedule_enabled;
                }

                // Update photo control pause button
                if (status.photo_control) {
                    const pauseBtn = document.getElementById('btn-pause');
                    const statusEl = document.getElementById('photo-control-status');
                    if (status.photo_control.paused) {
                        pauseBtn.innerHTML = '<span class="btn-icon">‚ñ∂</span><span class="btn-text">Resume</span>';
                        pauseBtn.className = 'btn btn-primary photo-control-btn';
                        statusEl.innerHTML = '<strong style="color: var(--warning);">Slideshow paused.</strong> Click Resume to continue auto-advance.';
                        statusEl.style.color = 'var(--text-secondary)';
                    } else {
                        pauseBtn.innerHTML = '<span class="btn-icon">‚è∏</span><span class="btn-text">Pause</span>';
                        pauseBtn.className = 'btn btn-primary photo-control-btn';
                        statusEl.textContent = 'Use these controls to navigate photos or pause the slideshow on a specific photo.';
                        statusEl.style.color = '';
                    }
                }

                document.getElementById('status-indicator').textContent = 'Connected';
                document.getElementById('status-indicator').className = 'status online';
            } catch (e) {
                document.getElementById('status-indicator').textContent = 'Disconnected';
                document.getElementById('status-indicator').className = 'status offline';
            }
        }

        // Source type tab switching
        document.querySelectorAll('.source-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.source-tab').forEach(t => {
                    t.classList.remove('active');
                    t.style.background = 'var(--card-bg)';
                    t.style.color = 'var(--text-secondary)';
                });
                tab.classList.add('active');
                tab.style.background = 'var(--sage-primary)';
                tab.style.color = 'white';

                const source = tab.dataset.source;
                document.getElementById('google-input').style.display = source === 'google' ? 'block' : 'none';
                document.getElementById('local-input').style.display = source === 'local' ? 'block' : 'none';
            });
        });

        // Load albums
        async function loadAlbums() {
            const albums = await apiCall('/api/albums');
            const list = document.getElementById('album-list');
            list.innerHTML = '';
            albums.forEach((album, index) => {
                const li = document.createElement('li');
                li.dataset.index = index;
                const displayName = album.name || 'Unnamed';
                const isLocal = album.type === 'local';
                const sourceLabel = isLocal ? 'Local' : 'Google';
                const sourceLocation = isLocal ? album.path : album.url;
                const lastSynced = album.last_synced ? formatSyncTime(album.last_synced) : 'Never synced';
                li.innerHTML = `
                    <label class="album-enabled-label">
                        <input type="checkbox" class="album-enabled-checkbox"
                               data-index="${index}" ${album.enabled ? 'checked' : ''}>
                        <span>Show</span>
                    </label>
                    <div class="album-details">
                        <div class="album-name-row">
                            <span class="album-name-wrapper">
                                <span class="source-badge" style="font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-right: 6px; background: ${isLocal ? '#6b7280' : 'var(--sage-primary)'}; color: white;">${sourceLabel}</span>
                                <span class="album-name editable" data-index="${index}">${displayName}</span>
                                <span class="album-photo-count">(${album.photo_count} photos)</span>
                            </span>
                            <span class="album-edit-wrapper hidden">
                                <input type="text" class="album-name-input" data-index="${index}"
                                       value="${album.name || ''}" placeholder="Name">
                                <button class="btn btn-small btn-save" data-index="${index}">Save</button>
                            </span>
                        </div>
                        <div class="album-url" style="font-size: 12px; color: var(--text-secondary); word-break: break-all;">${sourceLocation}</div>
                        <div class="album-last-synced" style="font-size: 11px; color: var(--text-muted);">Last synced: ${lastSynced}</div>
                    </div>
                    <button class="btn btn-small btn-danger" onclick="deleteAlbum(${index})">Delete</button>
                `;
                list.appendChild(li);
            });

            // Add event handlers for enabled checkboxes
            document.querySelectorAll('.album-enabled-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', async (e) => {
                    const index = e.target.dataset.index;
                    const enabled = e.target.checked;
                    await apiCall(`/api/albums/${index}/enabled`, 'POST', { enabled });
                });
            });

            // Click on album name to edit
            document.querySelectorAll('.album-name.editable').forEach(nameSpan => {
                nameSpan.addEventListener('click', (e) => {
                    const li = e.target.closest('li');
                    li.querySelector('.album-name-wrapper').classList.add('hidden');
                    li.querySelector('.album-edit-wrapper').classList.remove('hidden');
                    const input = li.querySelector('.album-name-input');
                    input.focus();
                    input.select();
                });
            });

            // Save button handler
            document.querySelectorAll('.btn-save').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const li = e.target.closest('li');
                    const input = li.querySelector('.album-name-input');
                    const index = input.dataset.index;
                    const name = input.value.trim();
                    await apiCall(`/api/albums/${index}/name`, 'POST', { name });
                    // Update display and switch back to view mode
                    li.querySelector('.album-name').textContent = name || 'Unnamed album';
                    li.querySelector('.album-name-wrapper').classList.remove('hidden');
                    li.querySelector('.album-edit-wrapper').classList.add('hidden');
                });
            });

            // Keyboard handlers for input
            document.querySelectorAll('.album-name-input').forEach(input => {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const li = e.target.closest('li');
                        li.querySelector('.btn-save').click();
                    } else if (e.key === 'Escape') {
                        // Cancel edit
                        const li = e.target.closest('li');
                        li.querySelector('.album-name-wrapper').classList.remove('hidden');
                        li.querySelector('.album-edit-wrapper').classList.add('hidden');
                    }
                });
            });
        }

        // Add Google Photos album
        document.getElementById('btn-add-album').addEventListener('click', async () => {
            const url = document.getElementById('new-album-url').value.trim();
            const name = document.getElementById('new-album-name').value.trim();
            if (!url) {
                alert('Please enter an album URL');
                return;
            }
            const result = await apiCall('/api/albums', 'POST', { url, name, type: 'google_photos' });
            if (result.error) {
                alert('Error: ' + result.error);
                return;
            }
            document.getElementById('new-album-url').value = '';
            document.getElementById('new-album-name').value = '';
            loadAlbums();
        });

        // Add local directory
        document.getElementById('btn-add-local').addEventListener('click', async () => {
            const path = document.getElementById('new-local-path').value.trim();
            const name = document.getElementById('new-local-name').value.trim();
            if (!path) {
                alert('Please enter a directory path');
                return;
            }
            const result = await apiCall('/api/albums', 'POST', { path, name, type: 'local' });
            if (result.error) {
                alert('Error: ' + result.error);
                return;
            }
            document.getElementById('new-local-path').value = '';
            document.getElementById('new-local-name').value = '';
            loadAlbums();
        });

        // Directory browser
        let currentBrowsePath = null;

        async function browsePath(path) {
            try {
                const result = await apiCall('/api/browse', 'POST', { path: path || undefined });
                if (result.error) {
                    alert('Error: ' + result.error);
                    return;
                }

                currentBrowsePath = result.current_path;
                document.getElementById('browser-path').textContent = result.current_path;

                // Update parent button visibility
                const parentBtn = document.getElementById('btn-browser-up');
                parentBtn.style.display = result.parent_path ? 'inline-block' : 'none';

                // Populate directory list
                const list = document.getElementById('browser-list');
                list.innerHTML = '';

                if (result.items.length === 0) {
                    const li = document.createElement('li');
                    li.style.color = 'var(--text-muted)';
                    li.style.fontStyle = 'italic';
                    li.textContent = 'No subdirectories';
                    list.appendChild(li);
                } else {
                    for (const item of result.items) {
                        const li = document.createElement('li');
                        let text = `üìÅ ${item.name}`;
                        if (item.photo_count !== undefined) {
                            text += `<span class="photo-count">(${item.photo_count} photos)</span>`;
                        }
                        li.innerHTML = text;
                        li.addEventListener('click', () => browsePath(item.path));
                        list.appendChild(li);
                    }
                }
            } catch (e) {
                alert('Error browsing: ' + e.message);
            }
        }

        // Browse button - open modal
        document.getElementById('btn-browse-dir').addEventListener('click', () => {
            document.getElementById('dir-browser-modal').style.display = 'flex';
            const currentPath = document.getElementById('new-local-path').value.trim();
            browsePath(currentPath || null);
        });

        // Parent directory button
        document.getElementById('btn-browser-up').addEventListener('click', () => {
            if (currentBrowsePath && currentBrowsePath !== '/') {
                const parent = currentBrowsePath.substring(0, currentBrowsePath.lastIndexOf('/')) || '/';
                browsePath(parent);
            }
        });

        // Select button - use current path
        document.getElementById('btn-browser-select').addEventListener('click', () => {
            document.getElementById('new-local-path').value = currentBrowsePath;
            document.getElementById('dir-browser-modal').style.display = 'none';
        });

        // Cancel button - close modal
        document.getElementById('btn-browser-cancel').addEventListener('click', () => {
            document.getElementById('dir-browser-modal').style.display = 'none';
        });

        // Close modal on background click
        document.getElementById('dir-browser-modal').addEventListener('click', (e) => {
            if (e.target.id === 'dir-browser-modal') {
                document.getElementById('dir-browser-modal').style.display = 'none';
            }
        });

        // Delete album
        async function deleteAlbum(index) {
            if (confirm('Delete this album?')) {
                await apiCall(`/api/albums/${index}`, 'DELETE');
                loadAlbums();
            }
        }

        // Mode selection buttons
        document.querySelectorAll('.btn-mode[data-mode]').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                apiCall(`/api/control/${mode}`, 'POST');
                setTimeout(loadStatus, 500);
            });
        });

        // Resume schedule button
        document.getElementById('btn-resume').addEventListener('click', () => {
            apiCall('/api/control/resume', 'POST');
            setTimeout(loadStatus, 500);
        });

        document.getElementById('btn-next').addEventListener('click', () => {
            apiCall('/api/control/next', 'POST');
        });

        // Photo control buttons
        document.getElementById('btn-prev').addEventListener('click', () => {
            apiCall('/api/control/prev', 'POST');
        });

        document.getElementById('btn-pause').addEventListener('click', () => {
            apiCall('/api/control/toggle_pause', 'POST');
            setTimeout(loadStatus, 300);
        });

        // Schedule enabled checkbox - immediate save
        document.getElementById('schedule-enabled-control').addEventListener('change', async (e) => {
            const enabled = e.target.checked;
            await apiCall('/api/schedule/enabled', 'POST', { enabled });
            setTimeout(loadStatus, 500);
        });

        // Sync progress polling
        let syncPollInterval = null;

        async function updateSyncProgress() {
            try {
                const progress = await apiCall('/api/sync/status');
                const progressDiv = document.getElementById('sync-progress');
                const stageHeader = document.getElementById('sync-stage-header');
                const albumInfo = document.getElementById('sync-album-info');
                const progressBar = document.getElementById('sync-progress-bar');
                const progressText = document.getElementById('sync-progress-text');
                const stopMessage = document.getElementById('sync-stop-message');
                const syncBtn = document.getElementById('btn-sync');
                const fullSyncBtn = document.getElementById('btn-full-sync');
                const stopBtn = document.getElementById('btn-stop-sync');

                if (progress.is_syncing) {
                    progressDiv.style.display = 'block';
                    syncBtn.disabled = true;
                    fullSyncBtn.disabled = true;
                    syncBtn.textContent = 'Syncing...';
                    stopBtn.disabled = false;
                    stopMessage.style.display = 'none';

                    // Stage header: "Stage X of Y: Description"
                    const stageNum = progress.current_stage || 1;
                    const totalStages = progress.total_stages || 3;
                    const stageDesc = progress.stage_description || 'Working...';
                    stageHeader.textContent = `Stage ${stageNum} of ${totalStages}: ${stageDesc}`;

                    if (progress.stage === 'scraping') {
                        albumInfo.textContent = `Album ${progress.current_album_index || progress.albums_done + 1} of ${progress.albums_total}: ${progress.album_name || 'Loading...'}`;
                        // Indeterminate progress during scraping
                        progressBar.style.width = '100%';
                        progressBar.style.background = 'linear-gradient(90deg, #4CAF50 25%, #8BC34A 50%, #4CAF50 75%)';
                        progressBar.style.backgroundSize = '200% 100%';
                        progressBar.style.animation = 'shimmer 1.5s infinite';
                        progressText.textContent = `Found ${progress.urls_found} photos so far`;
                    } else if (progress.stage === 'downloading') {
                        const pct = progress.downloads_total > 0
                            ? Math.round((progress.downloads_done / progress.downloads_total) * 100)
                            : 0;
                        albumInfo.textContent = progress.downloads_total > 0
                            ? `${progress.downloads_done} of ${progress.downloads_total} new photos`
                            : 'No new photos to download';
                        progressBar.style.width = pct + '%';
                        progressBar.style.background = '#4CAF50';
                        progressBar.style.animation = 'none';
                        progressText.textContent = pct + '%';
                    } else if (progress.stage === 'fetching_metadata') {
                        const pct = progress.downloads_total > 0
                            ? Math.round((progress.downloads_done / progress.downloads_total) * 100)
                            : 0;
                        albumInfo.textContent = progress.downloads_total > 0
                            ? `${progress.downloads_done} of ${progress.downloads_total} photos`
                            : 'No metadata to fetch';
                        progressBar.style.width = pct + '%';
                        progressBar.style.background = 'linear-gradient(90deg, var(--sage-primary), var(--sage-light))';
                        progressBar.style.animation = 'none';
                        progressText.textContent = pct + '%';
                    }
                } else if (progress.stage === 'complete' || progress.stage === 'stopped') {
                    const isStopped = progress.stage === 'stopped';
                    stageHeader.textContent = isStopped ? 'Sync stopped' : 'Sync complete!';
                    albumInfo.textContent = `Found ${progress.urls_found} photos total`;
                    progressBar.style.width = '100%';
                    progressBar.style.background = isStopped ? 'var(--warning)' : '#4CAF50';
                    progressBar.style.animation = 'none';
                    progressText.textContent = isStopped ? 'Stopped' : '100%';

                    // Show stop message if available
                    if (isStopped && progress.stop_message) {
                        stopMessage.textContent = `Saved: ${progress.stop_message}`;
                        stopMessage.style.display = 'block';
                    } else {
                        stopMessage.style.display = 'none';
                    }

                    syncBtn.disabled = false;
                    fullSyncBtn.disabled = false;
                    syncBtn.textContent = 'Sync Now';
                    stopBtn.disabled = true;

                    // Hide progress after 5 seconds (longer for stopped to show message)
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                        loadStatus();
                    }, isStopped ? 5000 : 3000);

                    // Stop polling
                    if (syncPollInterval) {
                        clearInterval(syncPollInterval);
                        syncPollInterval = null;
                    }
                } else {
                    // Idle state
                    progressDiv.style.display = 'none';
                    syncBtn.disabled = false;
                    fullSyncBtn.disabled = false;
                    syncBtn.textContent = 'Sync Now';
                    stopBtn.disabled = true;
                    if (syncPollInterval) {
                        clearInterval(syncPollInterval);
                        syncPollInterval = null;
                    }
                }
            } catch (e) {
                console.error('Error polling sync status:', e);
            }
        }

        // Shared sync trigger function
        async function triggerSync(fullSync) {
            const progressDiv = document.getElementById('sync-progress');
            const stageHeader = document.getElementById('sync-stage-header');
            const albumInfo = document.getElementById('sync-album-info');
            const progressBar = document.getElementById('sync-progress-bar');
            const progressText = document.getElementById('sync-progress-text');
            const stopMessage = document.getElementById('sync-stop-message');

            // Pre-flight check: ensure at least one album is enabled
            try {
                const albums = await apiCall('/api/albums');
                const enabledAlbums = albums.filter(a => a.enabled);
                if (enabledAlbums.length === 0) {
                    // Show error in progress box
                    progressDiv.style.display = 'block';
                    stageHeader.textContent = 'No albums enabled';
                    albumInfo.textContent = 'Enable at least one album in the Albums tab, then try again.';
                    progressBar.style.width = '0%';
                    progressText.textContent = '';
                    stopMessage.style.display = 'none';
                    // Hide after 4 seconds
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 4000);
                    return;
                }
            } catch (e) {
                console.error('Error checking albums:', e);
                // Continue anyway - backend will handle it
            }

            // Show progress immediately
            progressDiv.style.display = 'block';
            stageHeader.textContent = fullSync ? 'Starting full sync...' : 'Starting sync...';
            albumInfo.textContent = '';
            progressBar.style.width = '0%';
            progressText.textContent = '';
            stopMessage.style.display = 'none';

            document.getElementById('btn-sync').disabled = true;
            document.getElementById('btn-full-sync').disabled = true;
            document.getElementById('btn-sync').textContent = 'Syncing...';
            document.getElementById('btn-stop-sync').disabled = false;

            await apiCall('/api/sync', 'POST', { update_all_captions: fullSync });

            // Start polling for progress
            if (!syncPollInterval) {
                syncPollInterval = setInterval(updateSyncProgress, 1000);
            }
        }

        // Sync button (quick sync - new photos only)
        document.getElementById('btn-sync').addEventListener('click', () => triggerSync(false));

        // Full Sync button (re-fetch all metadata)
        document.getElementById('btn-full-sync').addEventListener('click', () => triggerSync(true));

        // Stop sync button
        document.getElementById('btn-stop-sync').addEventListener('click', async () => {
            const btn = document.getElementById('btn-stop-sync');
            btn.disabled = true;
            btn.textContent = 'Stopping...';
            await apiCall('/api/sync/stop', 'POST');
            // Let the polling update the UI
        });

        // Check sync status on page load and start polling if sync is in progress
        async function checkInitialSyncStatus() {
            try {
                const progress = await apiCall('/api/sync/status');
                if (progress.is_syncing && !syncPollInterval) {
                    // Sync is already running, start polling
                    syncPollInterval = setInterval(updateSyncProgress, 1000);
                }
                updateSyncProgress();
            } catch (e) {
                console.error('Error checking initial sync status:', e);
            }
        }
        checkInitialSyncStatus();

        // ========== Sync Settings ==========

        // Store original sync settings for change detection
        let syncSettingsOriginal = {};

        async function loadSyncSettings() {
            try {
                const settings = await apiCall('/api/sync/settings', 'GET');
                document.getElementById('sync-interval').value = settings.interval_minutes;
                document.getElementById('sync-time').value = settings.sync_time || '03:00';
                document.getElementById('sync-on-start').checked = settings.sync_on_start;
                document.getElementById('sync-max-dimension').value = settings.max_dimension;

                // Capture original values
                syncSettingsOriginal = {
                    interval_minutes: settings.interval_minutes,
                    sync_time: settings.sync_time || '03:00',
                    sync_on_start: settings.sync_on_start,
                    max_dimension: settings.max_dimension
                };
                document.getElementById('btn-save-sync').disabled = true;
            } catch (e) {
                console.error('Error loading sync settings:', e);
            }
        }

        function getSyncSettingsState() {
            return {
                interval_minutes: parseInt(document.getElementById('sync-interval').value),
                sync_time: document.getElementById('sync-time').value,
                sync_on_start: document.getElementById('sync-on-start').checked,
                max_dimension: parseInt(document.getElementById('sync-max-dimension').value) || 0
            };
        }

        function checkSyncSettingsChanges() {
            const current = getSyncSettingsState();
            const hasChanges = JSON.stringify(current) !== JSON.stringify(syncSettingsOriginal);
            document.getElementById('btn-save-sync').disabled = !hasChanges;
        }

        // Track changes on sync settings inputs
        ['sync-interval', 'sync-time', 'sync-on-start', 'sync-max-dimension'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', checkSyncSettingsChanges);
                if (el.type === 'number' || el.type === 'time') {
                    el.addEventListener('input', checkSyncSettingsChanges);
                }
            }
        });

        // Save sync settings
        document.getElementById('btn-save-sync').addEventListener('click', async () => {
            const btn = document.getElementById('btn-save-sync');
            btn.disabled = true;
            btn.textContent = 'Saving...';

            try {
                const data = getSyncSettingsState();
                const result = await apiCall('/api/sync/settings', 'POST', data);
                if (result.success) {
                    syncSettingsOriginal = data;
                    btn.textContent = 'Saved!';
                    setTimeout(() => {
                        btn.textContent = 'Save Sync Settings';
                    }, 1500);
                } else {
                    alert('Error: ' + (result.error || 'Unknown error'));
                    btn.textContent = 'Save Sync Settings';
                    btn.disabled = false;
                }
            } catch (e) {
                alert('Error saving sync settings: ' + e);
                btn.textContent = 'Save Sync Settings';
                btn.disabled = false;
            }
        });

        // Load sync settings on page load
        loadSyncSettings();

        // Load photos
        async function loadPhotos() {
            const photos = await apiCall('/api/photos');
            const grid = document.getElementById('photo-grid');
            const countSpan = document.getElementById('photo-grid-count');
            grid.innerHTML = '';

            const photoItems = photos.filter(p => p.type === 'photo');
            countSpan.textContent = `(${photoItems.length} photos)`;

            photoItems.forEach(photo => {
                const div = document.createElement('div');
                div.className = 'photo-thumb';
                div.innerHTML = `
                    <img src="/api/photos/${photo.id}/thumbnail"
                         alt="${photo.caption || ''}"
                         loading="lazy">
                    <span>${photo.caption || photo.date || ''}</span>
                `;
                grid.appendChild(div);
            });
        }

        // Clear cache button
        document.getElementById('btn-clear-cache').addEventListener('click', async () => {
            if (confirm('Are you sure you want to clear all cached photos? They will be re-downloaded on the next sync.')) {
                const btn = document.getElementById('btn-clear-cache');
                btn.disabled = true;
                btn.textContent = 'Clearing...';
                try {
                    const result = await apiCall('/api/cache/clear', 'POST');
                    if (result.success) {
                        alert('Cache cleared successfully. Run sync to re-download photos.');
                        loadStatus();
                        loadPhotos();
                    } else {
                        alert('Error: ' + (result.error || 'Unknown error'));
                    }
                } catch (e) {
                    alert('Error clearing cache: ' + e);
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'Clear Cache';
                }
            }
        });

        // Track display settings changes
        const displayInputs = ['photo-duration', 'transition-type', 'display-order', 'overlay-enabled', 'overlay-font-size'];
        const displayOriginalValues = {};

        function captureDisplayOriginalValues() {
            displayInputs.forEach(id => {
                const el = document.getElementById(id);
                displayOriginalValues[id] = el.type === 'checkbox' ? el.checked : el.value;
            });
        }

        function checkDisplayChanges() {
            const btn = document.getElementById('btn-save-display');
            let hasChanges = false;
            displayInputs.forEach(id => {
                const el = document.getElementById(id);
                const currentValue = el.type === 'checkbox' ? el.checked : el.value;
                if (currentValue !== displayOriginalValues[id]) {
                    hasChanges = true;
                }
            });
            btn.disabled = !hasChanges;
        }

        // Initialize original values and set up change listeners
        captureDisplayOriginalValues();
        document.getElementById('btn-save-display').disabled = true;
        displayInputs.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('change', checkDisplayChanges);
            if (el.type === 'number' || el.type === 'text') {
                el.addEventListener('input', checkDisplayChanges);
            }
        });

        // Save display settings
        document.getElementById('btn-save-display').addEventListener('click', async () => {
            const btn = document.getElementById('btn-save-display');
            btn.disabled = true;
            btn.textContent = 'Saving...';

            try {
                const data = {
                    photo_duration_seconds: document.getElementById('photo-duration').value,
                    transition_type: document.getElementById('transition-type').value,
                    order: document.getElementById('display-order').value,
                    overlay_enabled: document.getElementById('overlay-enabled').checked,
                    overlay_font_size: document.getElementById('overlay-font-size').value
                };

                const result = await apiCall('/api/display', 'POST', data);
                if (result.success) {
                    captureDisplayOriginalValues();  // Reset tracking
                    btn.textContent = 'Saved!';
                    setTimeout(() => {
                        btn.textContent = 'Save Display Settings';
                        // Button stays disabled since no changes now
                    }, 1500);
                } else {
                    alert('Error: ' + (result.error || 'Unknown error'));
                    btn.textContent = 'Save Display Settings';
                    btn.disabled = false;
                }
            } catch (e) {
                alert('Error saving settings: ' + e);
                btn.textContent = 'Save Display Settings';
                btn.disabled = false;
            }
        });

        // ========== Schedule (Screen Saver) Tab ==========

        // Store original state for change detection
        let scheduleOriginalState = null;

        // Format time for display (e.g., "00:00" -> "12:00 AM", "14:30" -> "2:30 PM")
        function formatTimeDisplay(time24) {
            if (time24 === '24:00' || time24 === '00:00') return '12:00 AM';
            const [h, m] = time24.split(':').map(Number);
            const suffix = h >= 12 ? 'PM' : 'AM';
            const h12 = h % 12 || 12;
            return `${h12}:${m.toString().padStart(2, '0')} ${suffix}`;
        }

        // Create an event row element
        function createEventRow(event, containerId) {
            const row = document.createElement('div');
            row.className = 'event-row';
            row.dataset.containerId = containerId;

            // Start time - input (may be replaced with fixed span later)
            const startInput = document.createElement('input');
            startInput.type = 'time';
            startInput.className = 'event-start';
            startInput.value = event.start_time;
            startInput.addEventListener('change', checkScheduleChanges);

            const separator = document.createElement('span');
            separator.className = 'event-separator';
            separator.textContent = 'to';

            // End time - input (may be replaced with fixed span later)
            const endInput = document.createElement('input');
            endInput.type = 'time';
            endInput.className = 'event-end';
            endInput.value = event.end_time === '24:00' ? '23:59' : event.end_time;
            endInput.addEventListener('change', checkScheduleChanges);

            const modeSelect = document.createElement('select');
            modeSelect.className = 'event-mode';
            ['slideshow', 'clock', 'black'].forEach(mode => {
                const option = document.createElement('option');
                option.value = mode;
                option.textContent = mode === 'black' ? 'Black Screen' : mode.charAt(0).toUpperCase() + mode.slice(1);
                if (mode === event.mode) option.selected = true;
                modeSelect.appendChild(option);
            });
            modeSelect.addEventListener('change', checkScheduleChanges);

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'btn-delete-event';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = 'Delete';
            deleteBtn.addEventListener('click', () => {
                const container = row.parentElement;
                row.remove();
                updateFixedTimes(container.id);
                checkScheduleChanges();
            });

            row.appendChild(startInput);
            row.appendChild(separator);
            row.appendChild(endInput);
            row.appendChild(modeSelect);
            row.appendChild(deleteBtn);

            return row;
        }

        // Update fixed times: first row start = 00:00, last row end = 24:00
        function updateFixedTimes(containerId) {
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('.event-row');

            rows.forEach((row, index) => {
                const isFirst = index === 0;
                const isLast = index === rows.length - 1;

                // Handle start time
                const startEl = row.querySelector('.event-start');
                const existingStartFixed = row.querySelector('.event-start-fixed');

                if (isFirst) {
                    // First row: fixed start at 00:00
                    if (startEl) {
                        const fixed = document.createElement('span');
                        fixed.className = 'event-start-fixed event-time-fixed';
                        fixed.textContent = '12:00 AM';
                        fixed.dataset.value = '00:00';
                        startEl.replaceWith(fixed);
                    }
                } else {
                    // Not first row: ensure it's an input
                    if (existingStartFixed) {
                        const input = document.createElement('input');
                        input.type = 'time';
                        input.className = 'event-start';
                        input.value = existingStartFixed.dataset.value || '00:00';
                        input.addEventListener('change', checkScheduleChanges);
                        existingStartFixed.replaceWith(input);
                    }
                }

                // Handle end time
                const endEl = row.querySelector('.event-end');
                const existingEndFixed = row.querySelector('.event-end-fixed');

                if (isLast) {
                    // Last row: fixed end at 24:00 (midnight)
                    if (endEl) {
                        const fixed = document.createElement('span');
                        fixed.className = 'event-end-fixed event-time-fixed';
                        fixed.textContent = '12:00 AM';
                        fixed.dataset.value = '24:00';
                        endEl.replaceWith(fixed);
                    }
                } else {
                    // Not last row: ensure it's an input
                    if (existingEndFixed) {
                        const input = document.createElement('input');
                        input.type = 'time';
                        input.className = 'event-end';
                        input.value = '23:59';
                        input.addEventListener('change', checkScheduleChanges);
                        existingEndFixed.replaceWith(input);
                    }
                }
            });
        }

        // Render events in a container
        function renderEventList(containerId, events) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            events.forEach(event => {
                container.appendChild(createEventRow(event, containerId));
            });
            updateFixedTimes(containerId);
        }

        // Add a new event to a container
        function addEvent(containerId) {
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('.event-row');
            let startTime = '00:00';
            if (rows.length > 0) {
                const lastRow = rows[rows.length - 1];
                // Get end time from either input or fixed span
                const endInput = lastRow.querySelector('.event-end');
                const endFixed = lastRow.querySelector('.event-end-fixed');
                if (endInput) {
                    startTime = endInput.value;
                } else if (endFixed) {
                    startTime = endFixed.dataset.value === '24:00' ? '23:00' : endFixed.dataset.value;
                }
            }
            const newEvent = { start_time: startTime, end_time: '24:00', mode: 'black' };
            container.appendChild(createEventRow(newEvent, containerId));
            updateFixedTimes(containerId);
            checkScheduleChanges();
        }

        // Collect events from a container
        function collectEvents(containerId) {
            const container = document.getElementById(containerId);
            const rows = container.querySelectorAll('.event-row');
            const events = [];
            rows.forEach(row => {
                // Get start time from input or fixed span
                const startInput = row.querySelector('.event-start');
                const startFixed = row.querySelector('.event-start-fixed');
                const startTime = startInput ? startInput.value : (startFixed ? startFixed.dataset.value : '00:00');

                // Get end time from input or fixed span
                const endInput = row.querySelector('.event-end');
                const endFixed = row.querySelector('.event-end-fixed');
                let endTime = endInput ? endInput.value : (endFixed ? endFixed.dataset.value : '24:00');

                // Convert 23:59 to 24:00 for storage
                if (endTime === '23:59') endTime = '24:00';

                const select = row.querySelector('.event-mode');
                events.push({
                    start_time: startTime,
                    end_time: endTime,
                    mode: select.value
                });
            });
            return events;
        }

        // Validate schedule for gaps and overlaps
        function validateSchedule(containerId) {
            const events = collectEvents(containerId);
            if (events.length === 0) return { valid: true };

            // Convert time string to minutes for comparison
            const toMinutes = (t) => {
                if (t === '24:00') return 24 * 60;
                const [h, m] = t.split(':').map(Number);
                return h * 60 + m;
            };

            // Sort events by start time
            events.sort((a, b) => toMinutes(a.start_time) - toMinutes(b.start_time));

            const errors = [];

            // Check that first event starts at 00:00
            if (events[0].start_time !== '00:00') {
                errors.push(`Schedule must start at 12:00 AM (found ${formatTimeDisplay(events[0].start_time)})`);
            }

            // Check that last event ends at 24:00
            if (events[events.length - 1].end_time !== '24:00') {
                errors.push(`Schedule must end at 12:00 AM (found ${formatTimeDisplay(events[events.length - 1].end_time)})`);
            }

            // Check each event and gaps/overlaps between consecutive events
            for (let i = 0; i < events.length; i++) {
                const event = events[i];
                const startMins = toMinutes(event.start_time);
                const endMins = toMinutes(event.end_time);

                // Check that end > start
                if (endMins <= startMins) {
                    errors.push(`Period ${i + 1}: End time must be after start time`);
                    continue;
                }

                // Check gap/overlap with next event
                if (i < events.length - 1) {
                    const nextEvent = events[i + 1];
                    const nextStartMins = toMinutes(nextEvent.start_time);

                    if (endMins < nextStartMins) {
                        errors.push(`Gap between ${formatTimeDisplay(event.end_time)} and ${formatTimeDisplay(nextEvent.start_time)}`);
                    } else if (endMins > nextStartMins) {
                        errors.push(`Overlap between periods ending at ${formatTimeDisplay(event.end_time)} and starting at ${formatTimeDisplay(nextEvent.start_time)}`);
                    }
                }
            }

            return { valid: errors.length === 0, errors };
        }

        // Get current schedule state for comparison
        function getScheduleState() {
            return JSON.stringify({
                default_screensaver_mode: document.getElementById('default-screensaver-mode').value,
                schedule_enabled: document.getElementById('schedule-enabled-control').checked,
                weekday_events: collectEvents('weekday-events'),
                weekend_events: collectEvents('weekend-events'),
                holidays_use_weekend: document.getElementById('holidays-use-weekend').checked,
                countries: Array.from(document.querySelectorAll('.holiday-country:checked')).map(cb => cb.value).sort()
            });
        }

        // Check if schedule has changes
        function checkScheduleChanges() {
            const btn = document.getElementById('btn-save-schedule');
            const hasChanges = scheduleOriginalState !== getScheduleState();
            btn.disabled = !hasChanges;
        }

        // Load schedule from API
        async function loadScheduleEvents() {
            try {
                const data = await apiCall('/api/schedule/events', 'GET');

                // Set default screensaver mode
                document.getElementById('default-screensaver-mode').value = data.default_screensaver_mode || 'black';

                // Set schedule enabled
                document.getElementById('schedule-enabled-control').checked = data.enabled;

                // Render event lists
                renderEventList('weekday-events', data.weekday_events || []);
                renderEventList('weekend-events', data.weekend_events || []);

                // Set holidays
                const useWeekend = data.holidays?.use_weekend_schedule || false;
                document.getElementById('holidays-use-weekend').checked = useWeekend;
                document.getElementById('holiday-countries').style.display = useWeekend ? 'block' : 'none';

                // Set country checkboxes
                const countries = data.holidays?.countries || [];
                document.querySelectorAll('.holiday-country').forEach(cb => {
                    cb.checked = countries.includes(cb.value);
                });

                // Capture original state
                scheduleOriginalState = getScheduleState();
                document.getElementById('btn-save-schedule').disabled = true;
            } catch (e) {
                console.error('Error loading schedule:', e);
            }
        }

        // Show/hide holiday countries based on checkbox
        document.getElementById('holidays-use-weekend').addEventListener('change', (e) => {
            document.getElementById('holiday-countries').style.display = e.target.checked ? 'block' : 'none';
            checkScheduleChanges();
        });

        // Track changes on other inputs
        document.getElementById('default-screensaver-mode').addEventListener('change', checkScheduleChanges);
        document.getElementById('schedule-enabled-control').addEventListener('change', checkScheduleChanges);
        document.querySelectorAll('.holiday-country').forEach(cb => {
            cb.addEventListener('change', checkScheduleChanges);
        });

        // Save schedule settings
        document.getElementById('btn-save-schedule').addEventListener('click', async () => {
            const btn = document.getElementById('btn-save-schedule');

            // Validate both schedules
            const weekdayValidation = validateSchedule('weekday-events');
            const weekendValidation = validateSchedule('weekend-events');

            const allErrors = [];
            if (!weekdayValidation.valid) {
                allErrors.push('Weekday schedule:', ...weekdayValidation.errors.map(e => '  ‚Ä¢ ' + e));
            }
            if (!weekendValidation.valid) {
                allErrors.push('Weekend schedule:', ...weekendValidation.errors.map(e => '  ‚Ä¢ ' + e));
            }

            if (allErrors.length > 0) {
                alert('Please fix schedule errors:\n\n' + allErrors.join('\n'));
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Saving...';

            try {
                const selectedCountries = Array.from(
                    document.querySelectorAll('.holiday-country:checked')
                ).map(cb => cb.value);

                const data = {
                    default_screensaver_mode: document.getElementById('default-screensaver-mode').value,
                    weekday_events: collectEvents('weekday-events'),
                    weekend_events: collectEvents('weekend-events'),
                    holidays: {
                        use_weekend_schedule: document.getElementById('holidays-use-weekend').checked,
                        countries: selectedCountries
                    }
                };

                const result = await apiCall('/api/schedule/events', 'POST', data);
                if (result.success) {
                    scheduleOriginalState = getScheduleState();
                    btn.textContent = 'Saved!';
                    setTimeout(() => {
                        btn.textContent = 'Save';
                    }, 1500);
                } else {
                    alert('Error: ' + (result.error || 'Unknown error'));
                    btn.textContent = 'Save';
                    btn.disabled = false;
                }
            } catch (e) {
                alert('Error saving schedule: ' + e);
                btn.textContent = 'Save';
                btn.disabled = false;
            }
        });

        // Load schedule events on page load
        loadScheduleEvents();

        // Track clock settings changes
        const clockInputs = [
            'clock-style', 'clock-size', 'clock-show-date',
            'weather-enabled', 'weather-city', 'weather-lat', 'weather-lon', 'weather-units', 'weather-font-size',
            'news-enabled', 'news-feeds', 'news-scroll-speed', 'news-refresh', 'news-max-headlines', 'news-font-size'
        ];
        const clockOriginalValues = {};

        function captureClockOriginalValues() {
            clockInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    if (el.type === 'checkbox') {
                        clockOriginalValues[id] = el.checked;
                    } else {
                        clockOriginalValues[id] = el.value;
                    }
                }
            });
        }

        function checkClockChanges() {
            const btn = document.getElementById('btn-save-clock');
            let hasChanges = false;
            clockInputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    const currentValue = el.type === 'checkbox' ? el.checked : el.value;
                    if (currentValue !== clockOriginalValues[id]) {
                        hasChanges = true;
                    }
                }
            });
            btn.disabled = !hasChanges;
        }

        // Show/hide weather settings based on checkbox
        document.getElementById('weather-enabled').addEventListener('change', (e) => {
            document.getElementById('weather-settings').style.display = e.target.checked ? 'block' : 'none';
            checkClockChanges();
        });

        // Show/hide news settings based on checkbox
        document.getElementById('news-enabled').addEventListener('change', (e) => {
            document.getElementById('news-settings').style.display = e.target.checked ? 'block' : 'none';
            checkClockChanges();
        });

        // Initialize clock tracking
        captureClockOriginalValues();
        document.getElementById('btn-save-clock').disabled = true;
        clockInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('change', checkClockChanges);
                if (el.type === 'number' || el.type === 'text' || el.tagName === 'TEXTAREA' || el.type === 'range') {
                    el.addEventListener('input', checkClockChanges);
                }
            }
        });

        // Save clock settings
        document.getElementById('btn-save-clock').addEventListener('click', async () => {
            const btn = document.getElementById('btn-save-clock');
            btn.disabled = true;
            btn.textContent = 'Saving...';

            try {
                // Parse news feeds from textarea
                const feedsText = document.getElementById('news-feeds').value;
                const feedUrls = feedsText.split('\n').map(s => s.trim()).filter(s => s.length > 0);

                const data = {
                    // Clock settings
                    clock_style: document.getElementById('clock-style').value,
                    clock_size: document.getElementById('clock-size').value,
                    clock_show_date: document.getElementById('clock-show-date').checked,
                    // Weather settings
                    weather_enabled: document.getElementById('weather-enabled').checked,
                    weather_city: document.getElementById('weather-city').value,
                    weather_latitude: document.getElementById('weather-lat').value || null,
                    weather_longitude: document.getElementById('weather-lon').value || null,
                    weather_units: document.getElementById('weather-units').value,
                    weather_font_size: parseInt(document.getElementById('weather-font-size').value) || 0,
                    // News settings
                    news_enabled: document.getElementById('news-enabled').checked,
                    news_feed_urls: feedUrls,
                    news_scroll_speed: parseInt(document.getElementById('news-scroll-speed').value),
                    news_refresh_interval: parseInt(document.getElementById('news-refresh').value),
                    news_max_headlines: parseInt(document.getElementById('news-max-headlines').value),
                    news_font_size: parseInt(document.getElementById('news-font-size').value) || 0
                };

                const result = await apiCall('/api/schedule', 'POST', data);
                if (result.success) {
                    captureClockOriginalValues();
                    btn.textContent = 'Saved!';
                    setTimeout(() => {
                        btn.textContent = 'Save';
                    }, 1500);
                } else {
                    alert('Error: ' + (result.error || 'Unknown error'));
                    btn.textContent = 'Save';
                    btn.disabled = false;
                }
            } catch (e) {
                alert('Error saving clock settings: ' + e);
                btn.textContent = 'Save';
                btn.disabled = false;
            }
        });

        // Initialize
        loadStatus();
        loadAlbums();
        loadPhotos();
        setInterval(loadStatus, 10000);
    </script>
</body>
</html>
